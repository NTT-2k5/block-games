<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title id="page-title">Columns Game</title>
    <style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f0f0f0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    touch-action: none;
}

#game-container {
    width: 100%;
    max-width: 550px;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh; /* Make game container take full viewport height */
    max-height: 100vh; /* Ensure it doesn't exceed viewport */
    padding: 5px; /* Add a little padding around the game container */
    box-sizing: border-box;
}

/* Modal Styles */
.modal {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.1); /* Darker background for better contrast */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding: 15px; /* Add padding for smaller screens */
    box-sizing: border-box;
}

.modal-content {
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 75%;
    max-height: 90vh; /* Prevent modal from being too tall */
    overflow-y: auto; /* Allow scrolling if content overflows */
}

.modal-content h2 {
    margin-top: 0;
    color: #333;
}

.modal-content p {
    text-align: left; /* Align rules to the left for readability */
    margin-bottom: 0px;
    line-height: 1.6;
    color: #555;
}

.modal-content ul {
    text-align: left;
    padding-left: 20px; /* Indent list items */
    margin-bottom: 15px;
}

.modal-content li {
    margin-bottom: 8px;
    line-height: 1.5;
    color: #555;
}

.modal-content button {
    padding: 10px 20px;
    margin: 10px;
    border: none;
    border-radius: 5px;
    background-color: #4CAF50;
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.modal-content button:hover {
    background-color: #45a049;
}

/* Specific style for How to Play button */
#how-to-play-btn {
    background-color: #2196F3; /* Blue background */
}

#how-to-play-btn:hover {
    background-color: #1c7cd6; /* Darker blue on hover */
}

.confirm-btn-yes {
    background-color: #F44336 !important; /* Red for confirmation */
}
.confirm-btn-yes:hover {
    background-color: #d32f2f !important; /* Darker red */
}
.confirm-btn-no {
    background-color: #757575 !important; /* Grey for cancel */
}
.confirm-btn-no:hover {
    background-color: #616161 !important; /* Darker grey */
}

.selector-container {
    margin-top: 10px;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%; /* Ensure full width for centering */
}

.selector-container label {
    margin-right: 8px;
    font-size: 1em;
    color: #555;
}

.selector-container select {
    padding: 5px 8px;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 0.95em;
}


/* Game Interface Styles */
#game-interface {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    flex-grow: 1;
    overflow: hidden;
    /* display: none; is handled by JS */
}

#stats-area {
    display: flex;
    flex-direction: row; /* Single row */
    align-items: center; /* Vertically align items */
    justify-content: space-around; /* Distribute space, helps when timer is hidden */
    width: 100%;
    padding: 5px 12px;
    background-color: #e0e0e0;
    border-radius: 5px;
    font-size: clamp(0.9em, 2.5vw, 1.1em); /* Base font size for the area */
    flex-shrink: 0;
    box-sizing: border-box;
    min-height: 50px; /* Ensure a minimum height for better vertical centering of larger items */
}

.stat-item {
    display: flex;
    align-items: center; /* Align emoji and number vertically */
    margin: 0 8px; /* Space between stat items, reduced slightly */
}

.stat-emoji {
    font-size: 1.7em; /* Larger emoji */
    margin-right: 6px; /* Space between emoji and number */
    line-height: 1; /* Improve vertical alignment of emoji */
}

.stat-value {
    font-size: 1.7em; /* Larger number */
    font-weight: bold;
    line-height: 1; /* Improve vertical alignment of numbers */
}

#time-left { /* Inherits .stat-value, specific for color */
    color: #4CAF50; /* Default green */
}

#pause-game-btn {
    background-color: transparent;
    border: none;
    font-size: 2.1em; /* Large pause emoji */
    color: #333; /* Default text color */
    cursor: pointer;
    padding: 0;
    margin-left: 8px; /* Space from the timer or highscore */
    line-height: 1; /* Crucial for emoji vertical alignment */
    display: flex; /* For centering emoji if it has intrinsic padding */
    align-items: center;
    justify-content: center;
}
#game-display-area {
    display: flex;
    width: 100%;
    flex-grow: 1; /* Allow this area to take remaining space after stats */
    min-height: 0; /* Important for flex children that need to scroll or manage overflow */
}

#columns-preview-area { /* Renamed from pairs-preview-area */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: top;
    margin-top: 20px;
    padding-right: clamp(10px, 3vw, 20px); /* Responsive padding */
    flex-shrink: 0;
    flex-basis: clamp(80px, 22vw, 130px); /* Adjusted base width for cycle button + less previews */
    position: relative;
}

.column-container { /* Renamed from pair-container */
    margin-bottom: clamp(15px, 3vh, 25px); /* Adjusted margin for fewer previews */
    text-align: center;
}

.column-label { /* Renamed from pair-label */
    font-size: clamp(0.9em, 2vw, 1.1em);
    margin-top: 10px; /* Adjusted margin */
    margin-bottom: 5px;
}

#current-column-display, #next-column-display { /* Combined, no next2 */
    display: flex;
    flex-direction: column; /* Stack blocks vertically */
    align-items: center;
}

#next-label {
    position: relative;
    z-index: 3;
    margin-bottom: 5px;
}

/* Styling for the 3-block column previews */
#current-column-display .block {
    margin: 2px 0; /* Small margin between blocks in the column */
}
#next-column-display .block {
    margin: 1px 0; /* Slightly smaller margin for next previews */
}

#cycle-order-btn { /* Renamed from save-pair-btn */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px;
    margin: 15px auto; /* Increased top margin due to less previews */
    border: none;
    border-radius: 5px;
    background-color: #e0e0e0;
    cursor: pointer;
    width: clamp(70px, 90%, 110px); /* Slightly wider for new text */
    font-size: clamp(0.9em, 2vw, 1.1em); /* Adjusted font size */
    box-sizing: border-box;
    position: relative;
    z-index: 5;
    min-height: 50px; /* Ensure enough height */
}

#cycle-btn-text-label { /* Renamed from save-btn-text-label */
    margin-bottom: 0; /* No blocks below it */
	// font-style: italic;
	font-weight: bold;
}


.block {
    margin: 1px 0;
    border-radius: clamp(4px, 1vw, 8px);
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: white;
    position: relative;
    box-shadow:
        inset 2px 2px 3px rgba(255, 255, 255, 0.3),
        inset -2px -2px 3px rgba(0, 0, 0, 0.2),
        2px 2px 5px rgba(0, 0, 0, 0.3);
    /* font-size will be set dynamically or based on context */
}

/* Block Colors (add yellow) */
.block.green { background-color: #4CAF50; }
.block.blue { background-color: #2196F3; }
.block.red { background-color: #F44336; }
.block.purple { background-color: #9C27B0; }
.block.orange { background-color: #FF9800; }
.block.yellow { background-color: #FFEB3B; color: #333; } /* Yellow color with dark text */


#playfield-container {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: top;
    margin-top: 15px;
    min-width: 0;
    position: relative;
}

#playfield {
    display: grid;
    grid-template-columns: repeat(6, var(--cell-size));
    grid-template-rows: repeat(12, var(--cell-size));
    background-color: #d3d3d3;
    border: 2px solid #cccccc;
    border-radius: 8px;
    gap: 2px;
    padding: 2px;
    position: relative;
    overflow: hidden; /* Important: This will clip blocks visually falling from above */
    max-width: 100%;
    max-height: 100%;
    box-sizing: content-box;
}

.playfield-cell {
    background-color: #e0e0e0;
    position: relative; /* For target marker */
}

.target-cell-marker::after {
    content: '√ó'; /* Cross mark */
    font-size: calc(var(--cell-size) * 0.9); /* Adjusted size relative to cell */
    color: rgba(255, 255, 255, 0.85);
    -webkit-text-stroke: 1px rgba(0,0,0,0.7); /* Outline for better visibility */
    text-stroke: 1px rgba(0,0,0,0.7);
    font-weight: bolder;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    line-height: 1; /* Ensure cross is centered */
    z-index: 15; /* Above blocks but below combo display */
    pointer-events: none; /* So it doesn't interfere with clicks on the cell */
}


.playfield-block {
    position: absolute;
    z-index: 10;
    margin: 0 !important;
}

.line {
  width: 65px;
  height: 0;
  border: 1px solid #C4C4C4;
  margin: 3px auto 5px auto;
  display:block;
}

.preview-column-block { /* For blocks shown during drag preview */
    opacity: 0.6;
    z-index: 5; /* Lower than placed blocks, higher than grid cells */
    position: absolute; /* Positioned by JS */
     box-shadow:
        inset 1px 1px 2px rgba(255, 255, 255, 0.2),
        inset -1px -1px 2px rgba(0, 0, 0, 0.1),
        1px 1px 3px rgba(0, 0, 0, 0.2); /* Softer shadow for preview */
}


.clearing {
    animation: clearAnimation 0.6s forwards;
}

@keyframes clearAnimation {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.5; }
    100% { transform: scale(0); opacity: 0; }
}

#dynamic-combo-display {
    position: absolute;
    font-size: 3.3rem;
    font-weight: bold;
    color: white;
    text-shadow: 3px 3px 3px rgba(0,0,0,0.6), 0 0 8px rgba(0,0,0,0.5);
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.3);
    transition: opacity 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275), transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    will-change: transform, opacity;
}

#dynamic-combo-display.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

#dynamic-combo-display.hide {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.3);
}


#dynamic-combo-display.high-combo {
    color: #FFD700;
    text-shadow: 1px 1px 2px #A0522D, 0 0 5px #B8860B, 0 0 10px #FF8C00;
}

/* Responsive adjustments */
@media (max-width: 600px) {
	.modal-content {
		max-width: 90%; /* Ensure modal fits on smaller screens */
	}
    #stats-area {
        font-size: 1em; /* Base for em units in stat items */
        padding: 6px 8px;
    }
    .stat-emoji {
        font-size: 1.7em;
    }
    .stat-value {
        font-size: 1.65em;
    }
    #pause-game-btn {
        font-size: 2em;
    }
}
@media (max-width: 400px) { /* Added finer grained responsive step */
    #stats-area {
        font-size: 0.9em;
        padding: 5px 6px;
        min-height: 40px;
    }
    .stat-item {
        margin: 0 4px;
    }
    .stat-emoji {
        font-size: 1.6em;
        margin-right: 3px;
    }
    .stat-value {
        font-size: 1.6em;
    }
}
@media (max-width: 300px) {
    #stats-area {
        font-size: 0.8em; /* Further reduction for very small screens */
    }
     .stat-emoji {
        font-size: 1.5em;
    }
    .stat-value {
        font-size: 1.5em;
    }
}
    </style>
</head>
<body>
    <div id="game-container">
        <div id="mode-selection-modal" class="modal">
            <div class="modal-content">
                <h2 id="main-menu-title">Columns Game</h2>

                <div class="selector-container">
                    <label for="difficulty-selector" id="difficulty-label">Difficulty:</label>
                    <select id="difficulty-selector">
                        <option value="easy">Easy (4 Colors)</option>
                        <option value="normal" selected>Normal (5 Colors)</option>
                        <option value="hard">Hard (6 Colors)</option>
                    </select>
                </div>

                <div class="selector-container">
                    <label for="start-height-selector" id="start-height-label">Start Height:</label>
                    <select id="start-height-selector">
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5" selected>5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                    </select>
                </div>

                <button id="relax-mode-btn">Relax Mode</button>
                <button id="timed-mode-btn">Timed Mode</button>
                <button id="pressure-mode-btn">Pressure Mode</button>
                <button id="target-mode-btn">Target Mode</button>
                <button id="how-to-play-btn">How to Play</button>

                <div class="selector-container" style="margin-top: 15px;">
                    <label for="language-selector" id="language-label">Language:</label>
                    <select id="language-selector">
                        <option value="en">English</option>
                        <option value="vi">Ti·∫øng Vi·ªát</option>
                    </select>
                </div>
            </div>
        </div>


        <div id="how-to-play-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="htp-title">How to Play</h2>
                <p><strong id="htp-objective-label">Objective:</strong> <span id="htp-objective-text"></span></p>
                <p><strong id="htp-gameplay-label">Gameplay:</strong></p>
                <ul>
                    <li id="htp-gameplay-rule1"></li>
                    <li id="htp-gameplay-rule2"></li>
                    <li id="htp-gameplay-rule3"></li>
                    <li id="htp-gameplay-rule4"></li>
                </ul>
                <p><strong id="htp-controls-label">Controls:</strong></p>
                <ul>
                    <li id="htp-controls-rule1"></li>
                    <li id="htp-controls-rule2"></li>
                    <li id="htp-controls-rule3"></li>
                </ul>
                <p><strong id="htp-gamemodes-label">Game Modes:</strong></p>
                <ul>
                    <li><strong id="htp-relaxmode-label">Relax Mode:</strong> <span id="htp-relaxmode-desc"></span></li>
                    <li><strong id="htp-timedmode-label">Timed Mode:</strong> <span id="htp-timedmode-desc"></span></li>
                    <li><strong id="htp-pressuremode-label">Pressure Mode:</strong> <span id="htp-pressuremode-desc"></span></li>
                    <li><strong id="htp-targetmode-label">Target Mode:</strong> <span id="htp-targetmode-desc"></span></li>
                </ul>
                <button id="close-how-to-play-btn">Got it!</button>
            </div>
        </div>


        <div id="game-interface" style="display: none;">
            <div id="stats-area">
                <div id="score-stat" class="stat-item">
                    <span class="stat-emoji">‚≠ê</span>
                    <span id="score" class="stat-value">0</span>
                </div>
                <div id="highscore-stat" class="stat-item">
                    <span class="stat-emoji">üèÜ</span>
                    <span id="highscore" class="stat-value">0</span>
                </div>
                <div id="timer-stat" class="stat-item" style="display: none;"> <span class="stat-emoji">‚åõ</span>
                    <span id="time-left" class="stat-value">0.0</span>
                </div>
                <button id="pause-game-btn" title="Pause/End Game">‚è∏</button>
            </div>

            <div id="game-display-area">
                <div id="columns-preview-area">
                    <div class="column-container current-column-container">
                        <div class="column-label" id="now-label"><b>NOW</b></div>
                        <div id="current-column-display">
                            <div class="block" id="current-block-top"></div>
                            <div class="block" id="current-block-middle"></div>
                            <div class="block" id="current-block-bottom"></div>
                        </div>
                    </div>
                    <div class="line"></div>

                    <div class="column-container next-column-container">
                        <div class="column-label" id="next-label">Next</div>
                        <div id="next-column-display">
                             <div class="block" id="next-block-top"></div>
                             <div class="block" id="next-block-middle"></div>
                             <div class="block" id="next-block-bottom"></div>
                        </div>
                        </div>
                    <button id="cycle-order-btn">
                        <span id="cycle-btn-text-label">Cycle Order</span>
                    </button>
                </div>
                <div id="playfield-container">
                    <div id="playfield">
                        </div>
                    <div id="dynamic-combo-display"></div>
                </div>
            </div>
        </div>

		<div id="confirm-end-game-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="confirm-end-game-title">Confirm</h2>
                <button id="confirm-end-game-yes-btn" class="confirm-btn-yes">Yes</button>
                <button id="confirm-end-game-no-btn" class="confirm-btn-no">No</button>
            </div>
        </div>

        <div id="game-over-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="game-over-title">Game Over</h2> <p id="final-score-line"><span class="label">Your Final Score: </span><span id="final-score">0</span></p>
                <p id="highscore-message-line" style="display: none;">High Score: <span id="final-highscore">0</span></p>
                <p id="max-combo-line"><span class="label">Max Combo: </span><span id="max-combo">0</span></p><br>
                <button id="main-menu-btn">Main Menu</button>
            </div>
        </div>
    </div>
    <script>
document.addEventListener('DOMContentLoaded', () => {
    // Game Elements
    const modeSelectionModal = document.getElementById('mode-selection-modal');
    const gameInterface = document.getElementById('game-interface');
    const gameOverModal = document.getElementById('game-over-modal');
    const howToPlayModal = document.getElementById('how-to-play-modal');
    const confirmEndGameModal = document.getElementById('confirm-end-game-modal');

    const difficultySelector = document.getElementById('difficulty-selector');
    const startHeightSelector = document.getElementById('start-height-selector');
    const relaxModeBtn = document.getElementById('relax-mode-btn');
    const timedModeBtn = document.getElementById('timed-mode-btn');
    const pressureModeBtn = document.getElementById('pressure-mode-btn');
    const targetModeBtn = document.getElementById('target-mode-btn');
    const howToPlayBtn = document.getElementById('how-to-play-btn');
    const closeHowToPlayBtn = document.getElementById('close-how-to-play-btn');
    const mainmenuBtn = document.getElementById('main-menu-btn');
    const confirmEndGameYesBtn = document.getElementById('confirm-end-game-yes-btn');
    const confirmEndGameNoBtn = document.getElementById('confirm-end-game-no-btn');

    const pauseGameBtn = document.getElementById('pause-game-btn');

    const scoreDisplay = document.getElementById('score');
    const highscoreDisplay = document.getElementById('highscore');
    const timerStatDisplay = document.getElementById('timer-stat');
    const timeLeftDisplay = document.getElementById('time-left');

    // Current Column Display
    const currentBlockTopDisplay = document.getElementById('current-block-top');
    const currentBlockMiddleDisplay = document.getElementById('current-block-middle');
    const currentBlockBottomDisplay = document.getElementById('current-block-bottom');

    // Next Column Display
    const nextBlockTopDisplay = document.getElementById('next-block-top');
    const nextBlockMiddleDisplay = document.getElementById('next-block-middle');
    const nextBlockBottomDisplay = document.getElementById('next-block-bottom');

    const cycleOrderBtn = document.getElementById('cycle-order-btn');

    const playfieldElement = document.getElementById('playfield');
    const playfieldContainer = document.getElementById('playfield-container');
    const finalScoreDisplay = document.getElementById('final-score');
    const finalScoreLine = document.getElementById('final-score-line');
    const maxcomboDisplay = document.getElementById('max-combo');
    const maxcomboLine = document.getElementById('max-combo-line');
    const highscoreMessageLine = document.getElementById('highscore-message-line');
    const finalHighscoreDisplay = document.getElementById('final-highscore');

    const dynamicComboDisplayElement = document.getElementById('dynamic-combo-display');
    let dynamicComboTimeout = null;

    // Language Elements
    const languageSelector = document.getElementById('language-selector');
    const languageLabel = document.getElementById('language-label');
    const pageTitleElement = document.getElementById('page-title');
    const difficultyLabel = document.getElementById('difficulty-label');
    const startHeightLabel = document.getElementById('start-height-label');
    const mainMenuTitle = document.getElementById('main-menu-title');
    const htpTitle = document.getElementById('htp-title');
    const htpObjectiveLabel = document.getElementById('htp-objective-label');
    const htpObjectiveText = document.getElementById('htp-objective-text');
    const htpGameplayLabel = document.getElementById('htp-gameplay-label');
    const htpGameplayRule1 = document.getElementById('htp-gameplay-rule1');
    const htpGameplayRule2 = document.getElementById('htp-gameplay-rule2');
    const htpGameplayRule3 = document.getElementById('htp-gameplay-rule3');
    const htpGameplayRule4 = document.getElementById('htp-gameplay-rule4');
    const htpControlsLabel = document.getElementById('htp-controls-label');
    const htpControlsRule1 = document.getElementById('htp-controls-rule1');
    const htpControlsRule2 = document.getElementById('htp-controls-rule2');
    const htpControlsRule3 = document.getElementById('htp-controls-rule3');
    const htpGameModesLabel = document.getElementById('htp-gamemodes-label');
    const htpRelaxModeLabel = document.getElementById('htp-relaxmode-label');
    const htpRelaxModeDesc = document.getElementById('htp-relaxmode-desc');
    const htpTimedModeLabel = document.getElementById('htp-timedmode-label');
    const htpTimedModeDesc = document.getElementById('htp-timedmode-desc');
    const htpPressureModeLabel = document.getElementById('htp-pressuremode-label');
    const htpPressureModeDesc = document.getElementById('htp-pressuremode-desc');
    const htpTargetModeLabel = document.getElementById('htp-targetmode-label');
    const htpTargetModeDesc = document.getElementById('htp-targetmode-desc');

    const nowLabel = document.getElementById('now-label');
    const nextLabel = document.getElementById('next-label');
    const cycleBtnTextLabel = document.getElementById('cycle-btn-text-label');
    const gameOverTitleElement = document.getElementById('game-over-title');
    const confirmEndGameTitle = document.getElementById('confirm-end-game-title');


    // Game Constants
    const ROWS = 12;
    const COLS = 6;
    const ALL_POSSIBLE_COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
    let CURRENT_COLORS = [];
    const BLOCKS_PER_COLOR_IN_BAG = 20;
    const FALL_SPEED = 50;
    const TIMED_MODE_DURATION = 100 * 1000;
    const PRESSURE_MODE_INITIAL_TIME = 10 * 1000;
    const PRESSURE_MODE_DECREMENT = 80;
    const PRESSURE_MODE_MIN_TIME = 500;
    const PRESSURE_MODE_THRESHOLD_TIME = 2000;
    const TARGET_MODE_START_SCORE = 3000;
    const TARGET_MODE_SCORE_DECREMENT_INTERVAL = 100;
    const TARGET_BLOCK_ROW = ROWS - 1;
    const TARGET_BLOCK_COL = 3;
    const GRID_PADDING = 2;
    const GRID_GAP = 2;
    const MAX_INITIAL_FILL_ATTEMPTS = 10000;


    // Game State Variables
    let gameMode = '';
    let difficulty = 'normal';
    let startHeight = 0;
    let score = 0;
    let currentHighScore = 0;
    let combo = 0;
    let maxcombo = 0;
    let playfield = [];
    let currentColumn = { blocks: [null, null, null] }; // top, middle, bottom
    let nextColumn = { blocks: [null, null, null] };
    let cellSize = 40;
    let allowInput = false;
    let isFalling = false;
    let gameTimerInterval = null;
    let pressureTimerInterval = null;
    let targetModeScoreInterval = null;

    let currentPressureTimeLimit = PRESSURE_MODE_INITIAL_TIME;
    let pressureTurnEffectiveTimeLimit = 0;
    let pressureTurnStartTime = 0;
    let remainingTimedModeTime = 0;

    let previewBlocks = [];
    let dragStartPos = null;
    let dragCurrentCol = -1;
    let dragStartClientY = 0;

    let currentLanguage = 'en';
    let blockBag = [];

    let isGamePaused = false;
    let pressureTimerRemainingBeforePause = 0;
    let pressureAnimationRequestFrameId = null;
    let targetModeScoreBeforePause = 0;


    const translations = {
        en: {
            pageTitle: "Columns Matching Game",
            mainMenuTitle: "Columns Matching Game",
            difficultyLabel: "Difficulty:",
            startHeightLabel: "Start Height:",
            easyDifficulty: "Easy (4 Colors)",
            normalDifficulty: "Normal (5 Colors)",
            hardDifficulty: "Hard (6 Colors)",
            relaxMode: "Relax Mode",
            timedMode: "Timed Mode",
            pressureMode: "Pressure Mode",
            targetMode: "Target Mode",
            howToPlay: "How to Play",
            languageSelectorLabel: "Language:",

            howToPlayTitle: "How to Play",
            htpObjectiveLabel: "<strong>Objective:</strong>",
            htpObjectiveText: "Arrange falling columns of three blocks to create matches of 3 or more same-colored blocks horizontally, vertically, or diagonally.",
            htpGameplayLabel: "<strong>Gameplay:</strong>",
            htpGameplayRule1: "A column of three blocks (NOW piece) will appear, along with a preview of the NEXT piece, which you can drop in the playfield.",
			htpGameplayRule2: "When 3 or more blocks of the same color align horizontally, vertically, or diagonally, they are cleared and you score points.",
            htpGameplayRule3: "Other blocks will fall down right after breaking a block, which can cause a chain reaction (combo). Creating more combos will score more points!",
            htpGameplayRule4: "The game ends if the playfield fills up and there's no space to place a new column at the top.",

            htpControlsLabel: "<strong>Controls:</strong>",
            htpControlsRule1: "Tap/click and drag left or right on the playfield to choose the column where the blocks column will drop. A preview will show the landing spot.",
            htpControlsRule2: "Release your finger/mouse to drop the column. You can drag off the playfield to cancel the drop.",
            htpControlsRule3: "Press the 'Cycle Order' button or Spacebar to change the order of blocks in the 'NOW' column.",

            htpGameModesLabel: "<strong>Game Modes:</strong>",
            htpRelaxModeLabel: "<strong>Relax Mode:</strong>",
            htpRelaxModeDesc: "Play at your own pace. No timers, no pressure!",
            htpTimedModeLabel: "<strong>Timed Mode:</strong>",
            htpTimedModeDesc: "Score as many points as you can before the 100-second timer runs out.",
            htpPressureModeLabel: "<strong>Pressure Mode:</strong>",
            htpPressureModeDesc: "You have limited time for each move. This time gets shorter with each placement! If time runs out, a column drops automatically at random position.",
            htpTargetModeLabel: "<strong>Target Mode:</strong>",
            htpTargetModeDesc: "Clear the target block (marked '√ó') at the bottom-center before your score reaches zero (starting at 3000, decreasing with time). If Start Height is 0 or 1, it will be auto-set to 2.", // Updated
            gotIt: "Got it!",

            nowLabel: "<b>NOW</b>",
            nextLabel: "Next",
            cycleOrderLabelText: "Cycle Order",

            gameOverTitle: "Game Over",
            youWinTitle: "You Win!",
            finalScoreLabelText: "Your Final Score: ",
            remainingTimeLabelText: "Time Score: ",
            newHighScoreMsg: "New High Score!",
            highScoreMsgPrefix: "High Score: ",
            maxComboLabelText: "Max Combo: ",
            mainMenuLabel: "Main Menu",

            confirmEndGameTitle: "Confirm End Game?",
            confirmEndGameYes: "Yes, End Game",
            confirmEndGameNo: "No, Continue",
            pauseButtonTitle: "Pause / End Game"
        },
        vi: {
            pageTitle: "Tr√≤ ch∆°i X·∫øp C·ªôt kh·ªëi",
            mainMenuTitle: "Tr√≤ ch∆°i X·∫øp C·ªôt kh·ªëi",
            difficultyLabel: "ƒê·ªô kh√≥:",
            startHeightLabel: "Chi·ªÅu cao b·∫Øt ƒë·∫ßu:",
            easyDifficulty: "D·ªÖ (4 m√†u)",
            normalDifficulty: "Th∆∞·ªùng (5 m√†u)",
            hardDifficulty: "Kh√≥ (6 m√†u)",
            relaxMode: "Ch·∫ø ƒë·ªô Th∆∞ gi√£n",
            timedMode: "Ch·∫ø ƒë·ªô T√≠nh gi·ªù",
            pressureMode: "Ch·∫ø ƒë·ªô √Åp l·ª±c",
            targetMode: "Ch·∫ø ƒë·ªô M·ª•c ti√™u",
            howToPlay: "H∆∞·ªõng d·∫´n ch∆°i",
            languageSelectorLabel: "Ng√¥n ng·ªØ:",

            howToPlayTitle: "H∆∞·ªõng d·∫´n ch∆°i",
            htpObjectiveLabel: "<strong>M·ª•c ti√™u:</strong>",
            htpObjectiveText: "S·∫Øp x·∫øp c√°c c·ªôt kh·ªëi r∆°i g·ªìm ba kh·ªëi ƒë·ªÉ t·∫°o th√†nh c√°c nh√≥m t·ª´ 3 kh·ªëi c√πng m√†u tr·ªü l√™n theo h√†ng ngang, h√†ng d·ªçc, ho·∫∑c ƒë∆∞·ªùng ch√©o.",
            htpGameplayLabel: "<strong>C√°ch ch∆°i:</strong>",
            htpGameplayRule1: "M·ªôt c·ªôt g·ªìm ba kh·ªëi (kh·ªëi HI·ªÜN T·∫†I) s·∫Ω xu·∫•t hi·ªán, c√πng v·ªõi kh·ªëi K·∫æ TI·∫æP, b·∫°n c√≥ th·ªÉ th·∫£ c√°c c·ªôt kh·ªëi n√†y tr√™n khu v·ª±c ch∆°i.",
            htpGameplayRule2: "Khi 3 kh·ªëi c√πng m√†u tr·ªü l√™n th·∫≥ng h√†ng ngang, d·ªçc, ho·∫∑c ch√©o, ch√∫ng s·∫Ω b·ªã ph√° v√† b·∫°n ghi ƒëi·ªÉm.",
            htpGameplayRule3: "C√°c kh·ªëi kh√°c s·∫Ω r∆°i xu·ªëng ngay sau khi ph√° kh·ªëi, c√≥ th·ªÉ g√¢y ra ph·∫£n ·ª©ng d√¢y chuy·ªÅn (chu·ªói). T·∫°o nhi·ªÅu chu·ªói s·∫Ω ghi ƒë∆∞·ª£c nhi·ªÅu ƒëi·ªÉm h∆°n!",
            htpGameplayRule4: "Tr√≤ ch∆°i k·∫øt th√∫c n·∫øu khu v·ª±c ch∆°i b·ªã l·∫•p ƒë·∫ßy v√† kh√¥ng c√≤n ƒë·ªß ch·ªó tr·ªëng ƒë·ªÉ ƒë·∫∑t th√™m m·ªôt c·ªôt kh·ªëi m·ªõi.",

            htpControlsLabel: "<strong>ƒêi·ªÅu khi·ªÉn:</strong>",
            htpControlsRule1: "Ch·∫°m/nh·∫•p chu·ªôt v√† k√©o sang tr√°i ho·∫∑c ph·∫£i tr√™n khu v·ª±c ch∆°i ƒë·ªÉ ch·ªçn c·ªôt m√† c·ªôt kh·ªëi s·∫Ω r∆°i xu·ªëng. M·ªôt h√¨nh xem tr∆∞·ªõc s·∫Ω hi·ªán ra n∆°i kh·ªëi s·∫Ω r∆°i xu·ªëng.",
            htpControlsRule2: "Th·∫£ tay/chu·ªôt ƒë·ªÉ th·∫£ c·ªôt kh·ªëi. B·∫°n c√≥ th·ªÉ h·ªßy ƒë·∫∑t kh·ªëi b·∫±ng c√°ch k√©o ra kh·ªèi khu v·ª±c ch∆°i.",
            htpControlsRule3: "Nh·∫•n n√∫t 'ƒê·∫£o th·ª© t·ª±' ho·∫∑c ph√≠m c√°ch (Space) ƒë·ªÉ thay ƒë·ªïi th·ª© t·ª± c√°c kh·ªëi trong c·ªôt 'HI·ªÜN T·∫†I'.",

            htpGameModesLabel: "<strong>Ch·∫ø ƒë·ªô ch∆°i:</strong>",
            htpRelaxModeLabel: "<strong>Ch·∫ø ƒë·ªô Th∆∞ gi√£n:</strong>",
            htpRelaxModeDesc: "Ch∆°i theo t·ªëc ƒë·ªô c·ªßa b·∫°n. Kh√¥ng gi·ªõi h·∫°n th·ªùi gian, kh√¥ng √°p l·ª±c!",
            htpTimedModeLabel: "<strong>Ch·∫ø ƒë·ªô T√≠nh gi·ªù:</strong>",
            htpTimedModeDesc: "Ghi c√†ng nhi·ªÅu ƒëi·ªÉm c√†ng t·ªët tr∆∞·ªõc khi h·∫øt 100 gi√¢y.",
            htpPressureModeLabel: "<strong>Ch·∫ø ƒë·ªô √Åp l·ª±c:</strong>",
            htpPressureModeDesc: "B·∫°n c√≥ th·ªùi gian gi·ªõi h·∫°n cho m·ªói l·∫ßn di chuy·ªÉn. Th·ªùi gian n√†y s·∫Ω ng·∫Øn d·∫ßn sau m·ªói l·∫ßn ƒë·∫∑t th√†nh c√¥ng! N·∫øu h·∫øt gi·ªù, m·ªôt c·ªôt s·∫Ω t·ª± ƒë·ªông r∆°i t·∫°i m·ªôt v·ªã tr√≠ ng·∫´u nhi√™n.",
            htpTargetModeLabel: "<strong>Ch·∫ø ƒë·ªô M·ª•c ti√™u:</strong>",
            htpTargetModeDesc: "H√£y ph√° kh·ªëi M·ª•c ti√™u (ƒë√°nh d·∫•u '√ó') ·ªü ƒë√°y khu v·ª±c ch∆°i tr∆∞·ªõc khi ƒëi·ªÉm c·ªßa b·∫°n gi·∫£m v·ªÅ kh√¥ng (b·∫Øt ƒë·∫ßu t·ª´ 3000, gi·∫£m d·∫ßn theo th·ªùi gian). N·∫øu Chi·ªÅu cao ban ƒë·∫ßu l√† 0 ho·∫∑c 1, n√≥ s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c ƒë·∫∑t th√†nh 2.", // Updated
            gotIt: "ƒê√£ hi·ªÉu!",

            nowLabel: "<b>HI·ªÜN T·∫†I</b>",
            nextLabel: "K·∫ø ti·∫øp",
            cycleOrderLabelText: "ƒê·∫£o th·ª© t·ª±",

            gameOverTitle: "Tr√≤ ch∆°i k·∫øt th√∫c",
            youWinTitle: "B·∫°n ƒë√£ th·∫Øng!",
            finalScoreLabelText: "ƒêi·ªÉm c·ªßa b·∫°n: ",
            remainingTimeLabelText: "ƒêi·ªÉm th·ªùi gian: ",
            newHighScoreMsg: "K·ª∑ l·ª•c m·ªõi!",
            highScoreMsgPrefix: "ƒêi·ªÉm cao: ",
            maxComboLabelText: "Chu·ªói t·ªëi ƒëa: ",
            mainMenuLabel: "Menu ch√≠nh",

            confirmEndGameTitle: "X√°c nh·∫≠n K·∫øt th√∫c tr√≤ ch∆°i?",
            confirmEndGameYes: "C√≥, K·∫øt th√∫c",
            confirmEndGameNo: "Kh√¥ng, Ti·∫øp t·ª•c",
            pauseButtonTitle: "T·∫°m d·ª´ng / K·∫øt th√∫c"
        }
    };

    function setLanguage(lang) {
        currentLanguage = lang;
        localStorage.setItem('columnsGameLanguage', lang);
        languageSelector.value = lang;

        const t = translations[lang] || translations.en;

        pageTitleElement.textContent = t.pageTitle;
        mainMenuTitle.textContent = t.mainMenuTitle;
        difficultyLabel.textContent = t.difficultyLabel;
        startHeightLabel.textContent = t.startHeightLabel;

        difficultySelector.options[0].textContent = t.easyDifficulty;
        difficultySelector.options[1].textContent = t.normalDifficulty;
        difficultySelector.options[2].textContent = t.hardDifficulty;

        relaxModeBtn.textContent = t.relaxMode;
        timedModeBtn.textContent = t.timedMode;
        pressureModeBtn.textContent = t.pressureMode;
        targetModeBtn.textContent = t.targetMode;
        howToPlayBtn.textContent = t.howToPlay;
        languageLabel.textContent = t.languageSelectorLabel; // This was the error line

        htpTitle.textContent = t.howToPlayTitle;
        htpObjectiveLabel.innerHTML = t.htpObjectiveLabel;
        htpObjectiveText.innerHTML = t.htpObjectiveText;
        htpGameplayLabel.innerHTML = t.htpGameplayLabel;
        htpGameplayRule1.innerHTML = t.htpGameplayRule1;
        htpGameplayRule2.innerHTML = t.htpGameplayRule2;
        htpGameplayRule3.innerHTML = t.htpGameplayRule3;
        htpGameplayRule4.innerHTML = t.htpGameplayRule4;

        htpControlsLabel.innerHTML = t.htpControlsLabel;
        htpControlsRule1.innerHTML = t.htpControlsRule1;
        htpControlsRule2.innerHTML = t.htpControlsRule2;
        htpControlsRule3.innerHTML = t.htpControlsRule3;

        htpGameModesLabel.innerHTML = t.htpGameModesLabel;
        htpRelaxModeLabel.innerHTML = t.htpRelaxModeLabel;
        htpRelaxModeDesc.innerHTML = t.htpRelaxModeDesc;
        htpTimedModeLabel.innerHTML = t.htpTimedModeLabel;
        htpTimedModeDesc.innerHTML = t.htpTimedModeDesc;
        htpPressureModeLabel.innerHTML = t.htpPressureModeLabel;
        htpPressureModeDesc.innerHTML = t.htpPressureModeDesc;
        htpTargetModeLabel.innerHTML = t.htpTargetModeLabel;
        htpTargetModeDesc.innerHTML = t.htpTargetModeDesc;
        closeHowToPlayBtn.textContent = t.gotIt;

        nowLabel.innerHTML = t.nowLabel;
        nextLabel.textContent = t.nextLabel;
        cycleBtnTextLabel.textContent = t.cycleOrderLabelText;

        document.querySelector('#max-combo-line .label').textContent = t.maxComboLabelText;
        mainmenuBtn.textContent = t.mainMenuLabel;

        confirmEndGameTitle.textContent = t.confirmEndGameTitle;
        confirmEndGameYesBtn.textContent = t.confirmEndGameYes;
        confirmEndGameNoBtn.textContent = t.confirmEndGameNo;

        if (pauseGameBtn) pauseGameBtn.title = t.pauseButtonTitle;
    }

    function loadLanguage() {
        const savedLang = localStorage.getItem('columnsGameLanguage');
        setLanguage(savedLang && translations[savedLang] ? savedLang : 'en');
    }

    languageSelector.addEventListener('change', (event) => setLanguage(event.target.value));

    function getHighScoreKey() {
        return `columnsHighScore_${gameMode}_${difficulty}_${startHeight}`;
    }
    function getHighScore() {
        return parseInt(localStorage.getItem(getHighScoreKey()) || '0', 10);
    }
    function setHighScore(newScore) {
        localStorage.setItem(getHighScoreKey(), newScore.toString());
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function setDifficultyColors() {
        difficulty = difficultySelector.value;
        switch (difficulty) {
            case 'easy': CURRENT_COLORS = getRandomElements(ALL_POSSIBLE_COLORS, 4); break;
            case 'hard': CURRENT_COLORS = [...ALL_POSSIBLE_COLORS]; break;
            default: CURRENT_COLORS = getRandomElements(ALL_POSSIBLE_COLORS, 5); break;
        }
    }

    function getRandomElements(arr, count) {
        return [...arr].sort(() => 0.5 - Math.random()).slice(0, count);
    }

    function generateBlockBag() {
        blockBag = [];
        CURRENT_COLORS.forEach(color => {
            for (let i = 0; i < BLOCKS_PER_COLOR_IN_BAG; i++) blockBag.push(color);
        });
        shuffleArray(blockBag);
    }

    function drawFromBag(count = 1) {
        const drawn = [];
        for (let i = 0; i < count; i++) {
            if (blockBag.length === 0) generateBlockBag();
            if (blockBag.length === 0) { // Safety net
                drawn.push(ALL_POSSIBLE_COLORS[Math.floor(Math.random() * ALL_POSSIBLE_COLORS.length)]);
                continue;
            }
            drawn.push(blockBag.shift());
        }
        return drawn;
    }

    function initGame() {
        modeSelectionModal.style.display = 'none';
        gameOverModal.style.display = 'none';
        howToPlayModal.style.display = 'none';
        confirmEndGameModal.style.display = 'none';
        gameInterface.style.display = 'flex';
        cycleOrderBtn.style.display = 'flex';

        isGamePaused = false;
        if (pressureAnimationRequestFrameId) cancelAnimationFrame(pressureAnimationRequestFrameId);
        if (pressureTimerInterval) clearTimeout(pressureTimerInterval);
        if (gameTimerInterval) clearInterval(gameTimerInterval);
        if (targetModeScoreInterval) clearInterval(targetModeScoreInterval);

        setDifficultyColors();
        startHeight = parseInt(startHeightSelector.value, 10);
        score = 0; combo = 0; maxcombo = 0;
        currentHighScore = getHighScore();
        updateScoreDisplay();
        highscoreDisplay.textContent = currentHighScore;
        timerStatDisplay.style.display = 'none';
        scoreDisplay.style.color = '#000';

        if (gameMode === 'timed') {
            timerStatDisplay.style.display = 'flex';
            startTimedModeTimer();
        } else if (gameMode === 'pressure') {
            timerStatDisplay.style.display = 'flex';
            currentPressureTimeLimit = PRESSURE_MODE_INITIAL_TIME;
            pressureTurnEffectiveTimeLimit = currentPressureTimeLimit;
            startPressureTurnTimer();
        } else if (gameMode === 'target') {
            score = TARGET_MODE_START_SCORE;
            updateScoreDisplay();
            if (startHeight < 2) startHeight = 2;
            startTargetModeTimer();
        }

        clearPlayfieldArray();
        generatePlayfieldCells();
        adjustCellSize(); 

        generateBlockBag();
        currentColumn = generateNewColumnDefinition();
        nextColumn = generateNewColumnDefinition();

        updatePreviewDisplays();

        allowInput = true; isFalling = false;
        dynamicComboDisplayElement.classList.remove('show', 'hide');
        removeTargetMarker();
        if (gameMode === 'target') addTargetMarker();

        console.log(`Game initialized: Mode=${gameMode}, Difficulty=${difficulty}, StartHeight=${startHeight}, HighScore=${currentHighScore}`);
    }

    function adjustCellSize() {
        const playfieldPaddingAndGapsHorizontal = GRID_PADDING * 2 + (COLS - 1) * GRID_GAP;
        const playfieldPaddingAndGapsVertical = GRID_PADDING * 2 + (ROWS - 1) * GRID_GAP;
        const gameDisplayAreaWidth = document.getElementById('game-display-area').offsetWidth;
        const previewAreaWidth = document.getElementById('columns-preview-area').offsetWidth;
        const playfieldCont = document.getElementById('playfield-container');
        playfieldCont.style.width = `calc(${gameDisplayAreaWidth}px - ${previewAreaWidth}px - 10px)`;
        const availableWidthForPlayfield = playfieldCont.clientWidth - playfieldPaddingAndGapsHorizontal;
        const availableHeightForPlayfield = playfieldCont.clientHeight - playfieldPaddingAndGapsVertical;
        const cellSizeBasedOnWidth = Math.floor(availableWidthForPlayfield / COLS);
        const cellSizeBasedOnHeight = Math.floor(availableHeightForPlayfield / ROWS);
        cellSize = Math.max(10, Math.min(cellSizeBasedOnWidth, cellSizeBasedOnHeight));
        document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);

        const previewBlockSize = Math.max(15, Math.floor(cellSize * 0.80));
        const currentPreviewBlockSize = Math.max(18, Math.floor(previewBlockSize * 1.15));
        document.querySelectorAll('#current-column-display .block').forEach(b => {
            b.style.width = `${currentPreviewBlockSize}px`; b.style.height = `${currentPreviewBlockSize}px`;
            b.style.fontSize = `${currentPreviewBlockSize * 0.5}px`; b.style.borderRadius = `${Math.floor(currentPreviewBlockSize * 0.2)}px`;
        });
        document.querySelectorAll('#next-column-display .block').forEach(b => {
            b.style.width = `${previewBlockSize}px`; b.style.height = `${previewBlockSize}px`;
            b.style.fontSize = `${previewBlockSize * 0.5}px`; b.style.borderRadius = `${Math.floor(previewBlockSize * 0.2)}px`;
        });
        document.documentElement.style.setProperty('--column-preview-height', `${previewBlockSize * 3 + 4}px`);

        playfieldElement.style.width = `${COLS * cellSize + (COLS - 1) * GRID_GAP}px`;
        playfieldElement.style.height = `${ROWS * cellSize + (ROWS - 1) * GRID_GAP}px`;

        fillInitialBlocks();
        renderPlayfield();
        if (gameMode === 'target') addTargetMarker();
    }

    window.addEventListener('resize', () => {
        if (gameInterface.style.display === 'flex') adjustCellSize();
    });

    function clearPlayfieldArray() {
        playfield = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
    }

    function generatePlayfieldCells() {
        playfieldElement.innerHTML = '';
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.classList.add('playfield-cell');
                cell.dataset.row = r; cell.dataset.col = c;
                playfieldElement.appendChild(cell);
            }
        }
    }

    function fillInitialBlocks() {
        if (startHeight === 0) return;
        let attempts = 0;
        while (attempts < MAX_INITIAL_FILL_ATTEMPTS) {
            attempts++;
            clearPlayfieldArray();
            let possible = true;
            for (let r = ROWS - 1; r >= ROWS - startHeight; r--) {
                for (let c = 0; c < COLS; c++) {
                    let placedWithoutMatch = false;
                    const shuffledColors = [...CURRENT_COLORS].sort(() => 0.5 - Math.random());
                    for (const color of shuffledColors) {
                        playfield[r][c] = { color: color, id: `init_${r}_${c}_${Math.random()}`.slice(0,15), isTarget: (gameMode === 'target' && r === TARGET_BLOCK_ROW && c === TARGET_BLOCK_COL) };
                        if (!checkMatchesAt(r, c, color) && !checkMatchesAround(r,c)) {
                            placedWithoutMatch = true; break;
                        }
                    }
                    if (!placedWithoutMatch) {
                        playfield[r][c] = null; possible = false; break;
                    }
                }
                if (!possible) break;
            }
            if (possible && !checkAllMatches().length > 0) { // Simpler checkAllMatches call
                console.log(`Initial fill successful after ${attempts} attempts.`); return;
            }
        }
        console.warn(`Failed to fill initial blocks without matches after ${MAX_INITIAL_FILL_ATTEMPTS} attempts. Clearing playfield.`);
        clearPlayfieldArray();
    }

    function checkMatchesAt(r, c, color) {
        const directions = [{ dr: 0, dc: 1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }, { dr: 1, dc: -1 }];
        for (const dir of directions) {
            let count = 1;
            for (let i = 1; i < 3; i++) {
                const nr = r + dir.dr * i, nc = c + dir.dc * i;
                if (isValidCell(nr, nc) && playfield[nr][nc] && playfield[nr][nc].color === color) count++; else break;
            }
            for (let i = 1; i < 3; i++) {
                const nr = r - dir.dr * i, nc = c - dir.dc * i;
                if (isValidCell(nr, nc) && playfield[nr][nc] && playfield[nr][nc].color === color) count++; else break;
            }
            if (count >= 3) return true;
        }
        return false;
    }
    function checkMatchesAround(r,c) {
        const neighbors = getNeighbors(r,c, true);
        for(const n of neighbors) {
            if(playfield[n.r][n.c] && checkMatchesAt(n.r, n.c, playfield[n.r][n.c].color)) return true;
        }
        return false;
    }

    function generateNewColumnDefinition() {
        const rand = Math.random(); let colors;
        if (rand < 0.10) { const color = drawFromBag(1)[0]; colors = [color, color, color]; }
        else if (rand < 0.40) { const d = drawFromBag(2); colors = [d[0], d[0], d[1]]; }
        else { colors = drawFromBag(3); }
        return { blocks: [colors[0], colors[1], colors[2]] };
    }

    function advanceColumns() {
        currentColumn = { ...nextColumn };
        nextColumn = generateNewColumnDefinition();
        updatePreviewDisplays();
    }

    function updatePreviewDisplays() {
        const displays = [
            { column: currentColumn, top: currentBlockTopDisplay, middle: currentBlockMiddleDisplay, bottom: currentBlockBottomDisplay },
            { column: nextColumn, top: nextBlockTopDisplay, middle: nextBlockMiddleDisplay, bottom: nextBlockBottomDisplay },
        ];
        displays.forEach(d => {
            if (d.column && d.column.blocks) {
                d.top.className = `block ${d.column.blocks[0] || ''}`;
                d.middle.className = `block ${d.column.blocks[1] || ''}`;
                d.bottom.className = `block ${d.column.blocks[2] || ''}`;
                d.top.textContent = ''; d.middle.textContent = ''; d.bottom.textContent = '';
            } else {
                d.top.className = 'block'; d.middle.className = 'block'; d.bottom.className = 'block';
                d.top.textContent = ''; d.middle.textContent = ''; d.bottom.textContent = '';
            }
        });
    }

    playfieldElement.addEventListener('mousedown', handleDragStart);
    playfieldElement.addEventListener('touchstart', handleDragStart, { passive: false });

    function handleDragStart(e) {
        if (!allowInput || isFalling || isGamePaused) return;
        e.preventDefault();
        const rect = playfieldElement.getBoundingClientRect();
        const clientX = e.clientX || e.touches[0].clientX;
        dragStartClientY = e.clientY || e.touches[0].clientY; // Retain for potential future use
        dragStartPos = { x: clientX }; // Store initial X

        // Check if the initial click/touch is horizontally outside the playfield
        if (clientX < rect.left || clientX > rect.right) {
            dragCurrentCol = -1; // Mark as horizontally outside
            clearPlacementPreview(); // Ensure no preview is shown
        } else {
            // Horizontally inside or on edge, calculate column
            let col = Math.floor((clientX - rect.left - GRID_PADDING) / (cellSize + GRID_GAP));
            dragCurrentCol = Math.max(0, Math.min(COLS - 1, col)); // Clamp to valid column index
            showPlacementPreview(dragCurrentCol); // Show preview for the targeted column
        }

        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);
    }

    function handleDragMove(e) {
        if (!dragStartPos || isGamePaused) return; // Ensure drag has started and game is active
        e.preventDefault();
        const clientX = e.clientX || e.touches[0].clientX;
        const playfieldRect = playfieldElement.getBoundingClientRect();

        let newTargetCol;

        if (clientX < playfieldRect.left || clientX > playfieldRect.right) {
            newTargetCol = -1; // Drag is horizontally outside the playfield
        } else {
            // Drag is horizontally inside the playfield, calculate the column
            let col = Math.floor((clientX - playfieldRect.left - GRID_PADDING) / (cellSize + GRID_GAP));
            newTargetCol = Math.max(0, Math.min(COLS - 1, col)); // Clamp to a valid column index
        }

        if (newTargetCol !== dragCurrentCol) { // If the targeted column has changed (or changed to/from being outside)
            dragCurrentCol = newTargetCol;
            if (dragCurrentCol !== -1) {
                showPlacementPreview(dragCurrentCol); // Now targeting a valid column, show preview
            } else {
                clearPlacementPreview(); // Moved outside, clear preview
            }
        } else if (dragCurrentCol !== -1 && previewBlocks.length === 0) {
            // Still targeting the same valid column, but no preview is shown (e.g., if dragged back in quickly)
            showPlacementPreview(dragCurrentCol); // Re-show preview
        }
        // If dragCurrentCol is -1 and newTargetCol is also -1 (still outside), do nothing.
        // If dragCurrentCol is valid, newTargetCol is the same, and preview exists, do nothing.
    }

    async function handleDragEnd(e) {
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('touchmove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);

        if (!dragStartPos || isGamePaused) { // Basic checks
            clearPlacementPreview();
            dragStartPos = null;
            dragCurrentCol = -1;
            return;
        }

        const playfieldRect = playfieldElement.getBoundingClientRect();
        let finalClientX;

        // Determine the final X coordinate from the event
        if (e.type === 'mouseup' && typeof e.clientX === 'number') {
            finalClientX = e.clientX;
        } else if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0) {
            finalClientX = e.changedTouches[0].clientX;
        } else if (dragStartPos) { // Fallback to the initial drag X if current cannot be determined (e.g. a tap)
            finalClientX = dragStartPos.x;
        } else {
            finalClientX = -1; // Cannot determine, assume invalid
        }

        clearPlacementPreview(); // Always clear the visual preview after the drag operation concludes.

        // Cancel placement if:
        // 1. The last known targeted column (dragCurrentCol) was invalid (-1), OR
        // 2. The final release point (finalClientX) is horizontally outside the playfield bounds.
        if (dragCurrentCol === -1 || finalClientX < playfieldRect.left || finalClientX > playfieldRect.right) {
            console.log("Placement cancelled: Drag ended outside horizontal playfield bounds or no valid column was targeted.");
            dragStartPos = null;
            dragCurrentCol = -1; // Ensure state is reset
            return;
        }

        // If dragCurrentCol is a valid column index (0 to COLS-1), proceed with placing the column.
        if (dragCurrentCol !== -1) {
            const targetCol = dragCurrentCol;
            let lowestRow = -1;
            // Find the lowest available spot in the target column
            for (let r = ROWS - 1; r >= 0; r--) {
                if (!playfield[r][targetCol]) {
                    lowestRow = r;
                    break;
                }
            }

            // Check if there's space for the 3 blocks of the column
            if (lowestRow >= 2 && !playfield[lowestRow][targetCol] && !playfield[lowestRow - 1][targetCol] && !playfield[lowestRow - 2][targetCol]) {
                allowInput = false;
                combo = 0; // Reset combo for a new piece drop

                // Define block data for the current column being placed
                const bData = { color: currentColumn.blocks[2], id: Date.now() + '_b' + Math.random(), isTarget: (gameMode === 'target' && lowestRow === TARGET_BLOCK_ROW && targetCol === TARGET_BLOCK_COL) };
                const mData = { color: currentColumn.blocks[1], id: Date.now() + '_m' + Math.random(), isTarget: (gameMode === 'target' && lowestRow - 1 === TARGET_BLOCK_ROW && targetCol === TARGET_BLOCK_COL) };
                const tData = { color: currentColumn.blocks[0], id: Date.now() + '_t' + Math.random(), isTarget: (gameMode === 'target' && lowestRow - 2 === TARGET_BLOCK_ROW && targetCol === TARGET_BLOCK_COL) };

                // Update playfield array
                playfield[lowestRow][targetCol] = bData;
                playfield[lowestRow - 1][targetCol] = mData;
                playfield[lowestRow - 2][targetCol] = tData;

                // Create visual blocks on the playfield
                createVisualBlock(bData.color, lowestRow, targetCol, bData.id);
                createVisualBlock(mData.color, lowestRow - 1, targetCol, mData.id);
                createVisualBlock(tData.color, lowestRow - 2, targetCol, tData.id);

                // Handle game mode specific logic (e.g., Pressure mode timer)
                if (gameMode === 'pressure') {
                    if (pressureTimerInterval) clearTimeout(pressureTimerInterval);
                    if (pressureAnimationRequestFrameId) cancelAnimationFrame(pressureAnimationRequestFrameId);
                    currentPressureTimeLimit = Math.max(PRESSURE_MODE_MIN_TIME, currentPressureTimeLimit - (currentPressureTimeLimit > PRESSURE_MODE_THRESHOLD_TIME ? PRESSURE_MODE_DECREMENT : Math.trunc(PRESSURE_MODE_DECREMENT / 10)));
                }

                advanceColumns(); // Prepare the next set of columns
                await handleGravityAndMatches(); // Process gravity and any resulting matches
            } else {
                // Not enough space or other issue, check for game over
                if (isGameOver()) {
					if (gameMode === 'target') score = 0;
                    handleGameOver();
                } else {
                    allowInput = true; // Re-enable input if game is not over
                }
            }
        }

        // Reset drag state for the next interaction
        dragStartPos = null;
        dragCurrentCol = -1;
    }

    function showPlacementPreview(col) {
        clearPlacementPreview();
        let lowestAvailableStartRow = -1;
        for (let r = ROWS - 3; r >= 0; r--) {
            if (!playfield[r][col] && !playfield[r+1][col] && !playfield[r+2][col]) {
                let groundFound = (r + 2 === ROWS - 1);
                if (!groundFound) {
                    if (playfield[r+3] && playfield[r+3][col]) groundFound = true;
                }
                if(groundFound){ lowestAvailableStartRow = r; break; }
            }
        }
        if(lowestAvailableStartRow === -1){
            for(let r=0; r <= ROWS - 3; r++){
                 if (!playfield[r][col] && !playfield[r+1][col] && !playfield[r+2][col]) {
                    lowestAvailableStartRow = r; break;
                 }
            }
        }

        if (lowestAvailableStartRow !== -1) {
            previewBlocks.push(createVisualBlock(currentColumn.blocks[0], lowestAvailableStartRow, col, null, true));
            previewBlocks.push(createVisualBlock(currentColumn.blocks[1], lowestAvailableStartRow + 1, col, null, true));
            previewBlocks.push(createVisualBlock(currentColumn.blocks[2], lowestAvailableStartRow + 2, col, null, true));
            previewBlocks.forEach(b => { if (b) playfieldElement.appendChild(b); });
        }
    }

    function clearPlacementPreview() {
        previewBlocks.forEach(block => { if (block && block.parentElement) block.remove(); });
        previewBlocks = [];
    }

    function isValidCell(row, col) { return row >= 0 && row < ROWS && col >= 0 && col < COLS; }

    function createVisualBlock(color, row, col, id = null, isPreview = false) {
        const blockElement = document.createElement('div');
        blockElement.classList.add('block', color || 'empty');
        blockElement.classList.toggle('preview-column-block', isPreview);
        blockElement.classList.toggle('playfield-block', !isPreview);
        blockElement.style.width = `${cellSize}px`; blockElement.style.height = `${cellSize}px`;
        blockElement.style.fontSize = `${cellSize * 0.5}px`;
        blockElement.style.left = `${GRID_PADDING + col * (cellSize + GRID_GAP)}px`;
        blockElement.style.top = `${GRID_PADDING + row * (cellSize + GRID_GAP)}px`;
        blockElement.style.borderRadius = `${Math.floor(cellSize * 0.2)}px`;
        if (id) blockElement.dataset.id = id;
        if (!isPreview && playfieldElement) playfieldElement.appendChild(blockElement);
        return blockElement;
    }

    function renderPlayfield() {
        playfieldElement.querySelectorAll('.playfield-block').forEach(b => b.remove());
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (playfield[r][c]) {
                    createVisualBlock(playfield[r][c].color, r, c, playfield[r][c].id, false);
                }
            }
        }
    }
    function addTargetMarker() {
        const cell = playfieldElement.querySelector(`.playfield-cell[data-row="${TARGET_BLOCK_ROW}"][data-col="${TARGET_BLOCK_COL}"]`);
        if (cell) cell.classList.add('target-cell-marker');
    }
    function removeTargetMarker() {
        const cell = playfieldElement.querySelector('.target-cell-marker');
        if (cell) cell.classList.remove('target-cell-marker');
    }

    function showDynamicCombo(comboValue, clearedPositions) {
        if (!clearedPositions || clearedPositions.length === 0) {
            dynamicComboDisplayElement.classList.remove('show', 'high-combo'); return;
        }
        let avgR = 0, avgC = 0;
        clearedPositions.forEach(p => { avgR += p.r; avgC += p.c; });
        avgR /= clearedPositions.length; avgC /= clearedPositions.length;
        dynamicComboDisplayElement.style.top = `${GRID_PADDING + avgR * (cellSize + GRID_GAP) + cellSize / 2}px`;
        dynamicComboDisplayElement.style.left = `${GRID_PADDING + avgC * (cellSize + GRID_GAP) + cellSize / 2}px`;
        dynamicComboDisplayElement.textContent = `${comboValue}√ó`;
        dynamicComboDisplayElement.classList.toggle('high-combo', comboValue >= 5);
        dynamicComboDisplayElement.classList.remove('hide');
        dynamicComboDisplayElement.classList.add('show');
        if (dynamicComboTimeout) clearTimeout(dynamicComboTimeout);
        dynamicComboTimeout = setTimeout(() => {
            dynamicComboDisplayElement.classList.remove('show');
            dynamicComboDisplayElement.classList.add('hide');
        }, 600);
    }

    async function handleGravityAndMatches() {
        isFalling = true; allowInput = false;
        let madeChange;
        do {
            madeChange = false;
            let fell = await applyGravity();
            if (fell) madeChange = true;

            const matchResult = await findAndClearMatches();
            if (matchResult.count > 0) {
                madeChange = true;
                combo = combo === 0 ? 1 : combo + 1;
                maxcombo = Math.max(maxcombo, combo);
                let pts = (combo < 4) ? matchResult.count * Math.pow(2, combo -1) : matchResult.count * 8 * (combo-3);
                if (gameMode !== 'target') score += pts;
                updateScoreDisplay();
                showDynamicCombo(combo, matchResult.positions);

                if (gameMode === 'target' && matchResult.targetCleared) {
                    handleGameOver(true); return;
                }
            }
        } while (madeChange);
        isFalling = false;
        if (isGameOver()) {
			if (gameMode === 'target') score = 0;
            handleGameOver();
        } else {
            if (!isGamePaused) {
                allowInput = true;
                if (gameMode === 'pressure') {
                    pressureTurnEffectiveTimeLimit = currentPressureTimeLimit;
                    startPressureTurnTimer();
                }
            }
        }
    }

    async function applyGravity() {
        let blocksFell = false; let maxFallDistance = 0;
        for (let c = 0; c < COLS; c++) {
            for (let r = ROWS - 2; r >= 0; r--) {
                if (playfield[r][c] && !playfield[r + 1][c]) {
                    let fallDist = 0;
                    for (let lookR = r + 1; lookR < ROWS; lookR++) {
                        if (!playfield[lookR][c]) fallDist++; else break;
                    }
                    if (fallDist > 0) {
                        const blockData = playfield[r][c];
                        playfield[r + fallDist][c] = blockData; playfield[r][c] = null;
                        blocksFell = true; maxFallDistance = Math.max(maxFallDistance, fallDist);
                        const visual = playfieldElement.querySelector(`.playfield-block[data-id="${blockData.id}"]`);
                        if (visual) {
                            const newTop = GRID_PADDING + (r + fallDist) * (cellSize + GRID_GAP);
                            const fallTime = fallDist * (FALL_SPEED / 1000);
                            visual.style.transition = 'none'; void visual.offsetHeight;
                            visual.style.transition = `top ${fallTime.toFixed(3)}s linear`;
                            visual.style.top = `${newTop}px`;
                        }
                    }
                }
            }
        }
        if (blocksFell) await new Promise(resolve => setTimeout(resolve, maxFallDistance * FALL_SPEED + 50));
        return blocksFell;
    }

    function getNeighbors(r, c, includeDiagonals = false) {
        const n = [];
        const dirs = [ {dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1} ];
        if (includeDiagonals) dirs.push({dr:-1,dc:-1},{dr:-1,dc:1},{dr:1,dc:-1},{dr:1,dc:1});
        for (const dir of dirs) {
            const nr = r + dir.dr, nc = c + dir.dc;
            if (isValidCell(nr, nc)) n.push({ r: nr, c: nc });
        }
        return n;
    }

    function checkAllMatches() {
        const toClearSet = new Set();
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (!playfield[r][c]) continue;
                const color = playfield[r][c].color;
                const directions = [ {dr:0,dc:1},{dr:1,dc:0},{dr:1,dc:1},{dr:1,dc:-1} ];
                for (const dir of directions) {
                    const line = [{r,c}];
                    for (let i = 1; i < Math.max(ROWS,COLS); i++) {
                        const nr = r + dir.dr * i, nc = c + dir.dc * i;
                        if (isValidCell(nr,nc) && playfield[nr][nc] && playfield[nr][nc].color === color) {
                            line.push({r:nr, c:nc});
                        } else break;
                    }
                    if (line.length >= 3) line.forEach(cell => toClearSet.add(`${cell.r}-${cell.c}`));
                }
            }
        }
        return Array.from(toClearSet).map(s => { const [r,c] = s.split('-').map(Number); return {r,c}; });
    }

    async function findAndClearMatches() {
        const matchedCellsRC = checkAllMatches();
        let targetCleared = false;
        if (matchedCellsRC.length > 0) {
            const clrPromises = [], posForCombo = [];
            for (const cellCoords of matchedCellsRC) {
                const {r,c} = cellCoords;
                posForCombo.push({r,c});
                if (playfield[r][c]) {
                    if (gameMode === 'target' && playfield[r][c].isTarget) targetCleared = true;
                    const bId = playfield[r][c].id;
                    const visual = playfieldElement.querySelector(`.playfield-block[data-id="${bId}"]`);
                    if (visual && !visual.classList.contains('clearing')) {
                        visual.classList.add('clearing');
                        clrPromises.push(new Promise(res => visual.addEventListener('animationend', () => { visual.remove(); res(); }, {once:true})));
                    } else if (visual) {
                        clrPromises.push(new Promise(res => setTimeout(() => { if(visual.parentElement) visual.remove(); res(); }, 600)));
                    }
                    playfield[r][c] = null;
                }
            }
            await Promise.all(clrPromises);
            return { count: matchedCellsRC.length, positions: posForCombo, targetCleared };
        }
        return { count: 0, positions: [], targetCleared: false };
    }

    function startTimedModeTimer() {
        remainingTimedModeTime = TIMED_MODE_DURATION; updateTimerDisplay(remainingTimedModeTime);
        if(gameTimerInterval) clearInterval(gameTimerInterval);
        gameTimerInterval = setInterval(() => {
            if (isGamePaused || !allowInput || isFalling) return;
            remainingTimedModeTime -= 100;
            if (remainingTimedModeTime <= 0) {
                remainingTimedModeTime = 0; clearInterval(gameTimerInterval); handleGameOver();
            }
            updateTimerDisplay(remainingTimedModeTime);
        }, 100);
    }

    function startPressureTurnTimer() {
        pressureTurnStartTime = Date.now(); updateTimerDisplay(pressureTurnEffectiveTimeLimit, pressureTurnEffectiveTimeLimit);
        if (!allowInput || isGamePaused) return;
        if (pressureTimerInterval) clearTimeout(pressureTimerInterval);
        pressureTimerInterval = setTimeout(() => {
            if (allowInput && !isGamePaused && gameMode === 'pressure' && !isFalling) autoPlacePressureBlock();
        }, pressureTurnEffectiveTimeLimit);
        if (pressureAnimationRequestFrameId) cancelAnimationFrame(pressureAnimationRequestFrameId);
        pressureAnimationRequestFrameId = requestAnimationFrame(updatePressureBar);
    }

    function updatePressureBar() {
        if (gameMode !== 'pressure' || isGamePaused || (!allowInput && !isFalling)) return;
        const elapTime = Date.now() - pressureTurnStartTime;
        const remTime = pressureTurnEffectiveTimeLimit - elapTime;
        if (remTime <= 0 && allowInput && !isFalling) {
            updateTimerDisplay(0, pressureTurnEffectiveTimeLimit);
            if(pressureAnimationRequestFrameId){cancelAnimationFrame(pressureAnimationRequestFrameId);pressureAnimationRequestFrameId=null;}
            return;
        }
        if (timerStatDisplay.style.display !== 'none') updateTimerDisplay(Math.max(0, remTime), pressureTurnEffectiveTimeLimit);
        if (pressureAnimationRequestFrameId) pressureAnimationRequestFrameId = requestAnimationFrame(updatePressureBar);
    }

    function startTargetModeTimer() {
        if(targetModeScoreInterval) clearInterval(targetModeScoreInterval);
        targetModeScoreInterval = setInterval(() => {
            if (isGamePaused || !allowInput || isFalling) return;
            score--; updateScoreDisplay();
            if (score <= 0) {
                score = 0; updateScoreDisplay(); clearInterval(targetModeScoreInterval); handleGameOver(false);
            }
        }, TARGET_MODE_SCORE_DECREMENT_INTERVAL);
    }

    function updateTimerDisplay(ms, totalMs = 0) {
        const secs = (ms / 1000).toFixed(1); timeLeftDisplay.textContent = `${secs}`;
        let perc = 100;
        if (gameMode === 'timed') {
            perc = (ms/TIMED_MODE_DURATION)*100; timeLeftDisplay.style.color = perc < 20 ? 'red':'#000';
        } else if (gameMode === 'pressure') {
            let den = totalMs > 0 ? totalMs : pressureTurnEffectiveTimeLimit;
            if(den > 0) perc = (ms/den)*100; else perc = ms > 0 ? 100:0;
            timeLeftDisplay.style.color = ms < PRESSURE_MODE_THRESHOLD_TIME ? 'red':'#000';
        } else timeLeftDisplay.style.color = '#000';
    }

    async function autoPlacePressureBlock() {
        if (!allowInput || isFalling || isGamePaused) return;
        allowInput = false; clearPlacementPreview();
        const availCols = [];
        for (let c = 0; c < COLS; c++) {
            if (!playfield[0][c] && !playfield[1][c] && !playfield[2][c]) availCols.push(c);
        }
        if (availCols.length === 0) { handleGameOver(); return; }
        const randCol = availCols[Math.floor(Math.random() * availCols.length)]; combo = 0;
        const bData={color:currentColumn.blocks[2],id:Date.now()+'_apb'+Math.random(),isTarget:(gameMode==='target'&&2===TARGET_BLOCK_ROW&&randCol===TARGET_BLOCK_COL)};
        const mData={color:currentColumn.blocks[1],id:Date.now()+'_apm'+Math.random(),isTarget:(gameMode==='target'&&1===TARGET_BLOCK_ROW&&randCol===TARGET_BLOCK_COL)};
        const tData={color:currentColumn.blocks[0],id:Date.now()+'_apt'+Math.random(),isTarget:(gameMode==='target'&&0===TARGET_BLOCK_ROW&&randCol===TARGET_BLOCK_COL)};
        playfield[2][randCol]=bData; playfield[1][randCol]=mData; playfield[0][randCol]=tData;
        createVisualBlock(bData.color,2,randCol,bData.id); createVisualBlock(mData.color,1,randCol,mData.id); createVisualBlock(tData.color,0,randCol,tData.id);
        currentPressureTimeLimit = Math.max(PRESSURE_MODE_MIN_TIME, currentPressureTimeLimit - (currentPressureTimeLimit > PRESSURE_MODE_THRESHOLD_TIME ? PRESSURE_MODE_DECREMENT : Math.trunc(PRESSURE_MODE_DECREMENT/10)));
        advanceColumns(); await handleGravityAndMatches();
    }

    function isGameOver() {
        for (let c=0; c<COLS; c++) if(!playfield[0][c]&&!playfield[1][c]&&!playfield[2][c]) return false;
        return true;
    }

    function handleGameOver(wonTargetMode = false) {
        console.log("Game Over! Target Won: " + wonTargetMode);
        allowInput = false; isFalling = true;
        if(gameTimerInterval) clearInterval(gameTimerInterval);
        if(pressureTimerInterval) clearTimeout(pressureTimerInterval);
        if(pressureAnimationRequestFrameId) cancelAnimationFrame(pressureAnimationRequestFrameId);
        if(targetModeScoreInterval) clearInterval(targetModeScoreInterval);
        if(dynamicComboTimeout) clearTimeout(dynamicComboTimeout);
        confirmEndGameModal.style.display = 'none'; isGamePaused = false;
        const tr = translations[currentLanguage] || translations.en;
        let finalScoreVal = score;
        if (wonTargetMode) {
            gameOverTitleElement.textContent = tr.youWinTitle;
            document.querySelector('#final-score-line .label').textContent = tr.remainingTimeLabelText;
        } else {
            gameOverTitleElement.textContent = tr.gameOverTitle;
            document.querySelector('#final-score-line .label').textContent = tr.finalScoreLabelText;
        }
        finalScoreDisplay.textContent = finalScoreVal;
        maxcomboDisplay.textContent = maxcombo; maxcomboLine.style.display = 'block';
        const oldHS = getHighScore();
        if (finalScoreVal > oldHS) {
            setHighScore(finalScoreVal);
            highscoreMessageLine.innerHTML = tr.newHighScoreMsg;
            highscoreMessageLine.style.display = 'block'; finalHighscoreDisplay.textContent = finalScoreVal;
        } else if (oldHS > 0) {
            highscoreMessageLine.innerHTML = `${tr.highScoreMsgPrefix}<span id="final-highscore">${oldHS}</span>`;
            highscoreMessageLine.style.display = 'block'; finalHighscoreDisplay.textContent = oldHS;
        } else highscoreMessageLine.style.display = 'none';
        gameInterface.style.display = 'flex'; gameOverModal.style.display = 'flex';
    }

    function updateScoreDisplay() {
        scoreDisplay.textContent = score;
        if (gameMode === 'target') scoreDisplay.style.color = score < 500 ? 'red' : '#000';
    }

    function cycleCurrentColumnOrder() {
        if (!allowInput || isFalling || isGamePaused) {
            if (!(dragStartPos && !isFalling && !isGamePaused)) return;
        }
        const oldTop = currentColumn.blocks[0];
        currentColumn.blocks[0] = currentColumn.blocks[2];
        currentColumn.blocks[2] = currentColumn.blocks[1];
        currentColumn.blocks[1] = oldTop;
        updatePreviewDisplays();
        if (dragStartPos && dragCurrentCol !== -1 && !isFalling && !isGamePaused) {
            showPlacementPreview(dragCurrentCol);
        }
    }
    cycleOrderBtn.addEventListener('click', cycleCurrentColumnOrder);
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && gameInterface.style.display === 'flex' && !isGamePaused) {
            e.preventDefault(); cycleCurrentColumnOrder();
        }
    });

    relaxModeBtn.addEventListener('click', () => { gameMode = 'relax'; initGame(); });
    timedModeBtn.addEventListener('click', () => { gameMode = 'timed'; initGame(); });
    pressureModeBtn.addEventListener('click', () => { gameMode = 'pressure'; initGame(); });
    targetModeBtn.addEventListener('click', () => { gameMode = 'target'; initGame(); });
    howToPlayBtn.addEventListener('click', () => { howToPlayModal.style.display = 'flex'; });
    closeHowToPlayBtn.addEventListener('click', () => { howToPlayModal.style.display = 'none'; });

    mainmenuBtn.addEventListener('click', () => {
        gameOverModal.style.display = 'none'; gameInterface.style.display = 'none';
        cycleOrderBtn.style.display = 'none'; confirmEndGameModal.style.display = 'none';
        modeSelectionModal.style.display = 'flex';
        allowInput=false;isFalling=false;isGamePaused=false;
        if(gameTimerInterval)clearInterval(gameTimerInterval); if(pressureTimerInterval)clearTimeout(pressureTimerInterval);
        if(pressureAnimationRequestFrameId)cancelAnimationFrame(pressureAnimationRequestFrameId);
        if(targetModeScoreInterval)clearInterval(targetModeScoreInterval); if(dynamicComboTimeout)clearTimeout(dynamicComboTimeout);
        dynamicComboDisplayElement.classList.remove('show','hide','high-combo'); removeTargetMarker();
        loadLanguage();
    });

    pauseGameBtn.addEventListener('click', () => {
        if (gameOverModal.style.display === 'flex' || isGamePaused || gameInterface.style.display === 'none') return;
        isGamePaused = true; allowInput = false;
        confirmEndGameModal.style.display = 'flex';
        if (gameMode === 'pressure') {
            if(pressureTimerInterval) clearTimeout(pressureTimerInterval);
            if(pressureAnimationRequestFrameId){cancelAnimationFrame(pressureAnimationRequestFrameId);pressureAnimationRequestFrameId=null;}
            pressureTimerRemainingBeforePause = pressureTurnEffectiveTimeLimit - (Date.now() - pressureTurnStartTime);
            if(pressureTimerRemainingBeforePause < 0) pressureTimerRemainingBeforePause = 0;
        } else if (gameMode === 'target') targetModeScoreBeforePause = score;
        if (timerStatDisplay.style.display === 'flex') timeLeftDisplay.style.opacity = '0.5';
        if (gameMode === 'target') scoreDisplay.style.opacity = '0.5';
    });

    confirmEndGameYesBtn.addEventListener('click', () => {
        if (timerStatDisplay.style.display === 'flex') timeLeftDisplay.style.opacity = '1';
        if (gameMode === 'target') scoreDisplay.style.opacity = '1';
        isGamePaused = false;
        if (gameMode === 'target') score = 0;
        handleGameOver(false);
    });

    confirmEndGameNoBtn.addEventListener('click', () => {
        confirmEndGameModal.style.display = 'none';
        isGamePaused = false; allowInput = true;
        if (timerStatDisplay.style.display === 'flex') timeLeftDisplay.style.opacity = '1';
        if (gameMode === 'target') scoreDisplay.style.opacity = '1';
        if (gameMode === 'pressure') {
            pressureTurnEffectiveTimeLimit = pressureTimerRemainingBeforePause;
            pressureTurnStartTime = Date.now();
            if (pressureTurnEffectiveTimeLimit > 0) {
                if(pressureTimerInterval) clearTimeout(pressureTimerInterval);
                pressureTimerInterval = setTimeout(() => {
                    if(allowInput && !isGamePaused && gameMode === 'pressure' && !isFalling) autoPlacePressureBlock();
                }, pressureTurnEffectiveTimeLimit);
                if(pressureAnimationRequestFrameId) cancelAnimationFrame(pressureAnimationRequestFrameId);
                pressureAnimationRequestFrameId = requestAnimationFrame(updatePressureBar);
            } else if (allowInput && !isGamePaused && gameMode === 'pressure' && !isFalling) autoPlacePressureBlock();
        } else if (gameMode === 'timed') updateTimerDisplay(remainingTimedModeTime); // No need to restart interval, it checks isGamePaused
        else if (gameMode === 'target') { score = targetModeScoreBeforePause; updateScoreDisplay(); } // Interval also checks isGamePaused
    });

    loadLanguage();
    modeSelectionModal.style.display = 'flex';
    cycleOrderBtn.style.display = 'none';
    gameInterface.style.display = 'none';
    allowInput = false;
});
</script>
</body>
</html>